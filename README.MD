# Отчет по реализации реактивной библиотеки RxJava-подобной системы

## 1. Архитектура системы

### 1.1 Базовые компоненты

    Реализованная система представляет собой упрощенную версию реактивной библиотеки, построенной по принципам RxJava. Основные компоненты:

## 1. Интерфейс Observer<T>:

    onNext(T item) - получение элементов потока
    onError(Throwable t) - обработка ошибок
    onComplete() - обработка завершения потока
    isDisposed() - проверка состояния подписки

## 2. Класс Observable<T>:

    Ядро системы, представляющее поток данных
    Реализует паттерн "Наблюдатель"
    Поддерживает цепочки операторов
    Обеспечивает управление потоками выполнения

## 3. Интерфейс Disposable:

    dispose() - отмена подписки
    isDisposed() - проверка состояния

### 1.2 Операторы преобразования

    Система включает основные операторы:
        map(Function<T,R> mapper):
            Преобразует каждый элемент потока
            Сохраняет порядок элементов
            Не изменяет временные характеристики
        filter(Predicate<T> predicate):
            Фильтрует элементы по условию
            Пропускает только элементы, удовлетворяющие предикату
        flatMap(Function<T,Observable<R>> mapper):
            Преобразует каждый элемент в новый Observable
            Объединяет результаты в один поток
            Поддерживает асинхронные операции

### 1.3 Управление потоками

    Система предоставляет два основных метода для управления потоками:
        subscribeOn(Scheduler scheduler):
            Определяет поток, в котором будет выполняться подписка
            Влияет на источник данных
        observeOn(Scheduler scheduler):
            Определяет поток для обработки элементов
            Влияет на последующие операторы

## 2. Принципы работы Schedulers

### 2.1 Интерфейс Scheduler
        Базовый интерфейс с единственным методом:
            void execute(Runnable task);

### 2.2 Реализации Scheduler

    IOThreadScheduler:
        Аналог Schedulers.io() в RxJava
        Использует Executors.newCachedThreadPool()
        Оптимален для I/O операций (сетевые запросы, работа с файлами)
        Создает потоки по мере необходимости
        Переиспользует незанятые потоки
    ComputationScheduler:
        Аналог Schedulers.computation()
        Использует Executors.newFixedThreadPool() с размером = количеству ядер CPU
        Оптимален для CPU-интенсивных операций
        Ограничивает параллелизм для избежания перегрузки CPU
    SingleThreadScheduler:
        Аналог Schedulers.single()
        Использует Executors.newSingleThreadExecutor()
        Гарантирует последовательное выполнение задач
        Полезен для синхронизации доступа к общим ресурсам

### 2.3 Области применения

| Scheduler             | Использование                             | Не рекомендуется для     |
|-----------------------|-------------------------------------------|--------------------------|
| IOThreadScheduler     | Сетевые запросы, работа с файлами         | CPU-интенсивных операций |
| ComputationScheduler  | Вычисления, обработка данных              | I/O операций             |
| SingleThreadScheduler | Последовательная обработка, синхронизация | Параллельных задач       |

## 3. Процесс тестирования

### Основные тестовые сценарии

    Всего реализовано 9 тестов, которые полностью покрывают:
        Базовый функционал Observable:
            Создание и подписка
            Эмиссия элементов
            Завершение потока
        Операторы преобразования:
            Корректность работы map
            Фильтрация элементов filter
            Преобразование flatMap
        Управление потоками:
            Проверка subscribeOn
            Проверка observeOn
            Комбинация schedulers
        Обработка ошибок:
            Передача ошибок через onError
            Поведение после ошибки
            Отмена подписки при ошибке
        Disposable:
            Отмена подписки
            Проверка isDisposed
            Поведение после отмены

## 4. Примеры использования

### Для запуска проекта выполните следующие шаги:

    1. Клонируйте репозиторий:

```bash
git clone https://github.com/nikolay-977/custom-rx-java
cd custom-rx-java
 ```

    2. Скомпилируйте проект:

```bash
mvn compile
 ```

    3. Запустите:

```bash
mvn exec:java
 ```
